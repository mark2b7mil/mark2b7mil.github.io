___

# Operating Systems and Containerization

Operating system goals that relate to access control are, process isolation, programming abstraction, and restricting resource consumption. OSes must design for multi process use so that the processes do not interfere with one another but can communicate if need be. Abstraction refers to the ability for programmers to interact with the OS in ways that make sense for people. Writing code to interact with the OS, like system calls on Linux. Restricting resource consumption is necessary so that one process does not take up all the resources of the machine, or a malicious code does not do too much damage. Containerization allows the OS to simplify things in terms of security and handle the above goals easier. There have been exploits where a user can overload the memory or disk on a system without the OS stepping in and effectively crash the system. Fork bombs recursively create processes which quickly plug up the amount of processes the OS can create. Resource isolation in the form of leaving space on a disk or memory, or leaving the root user a number of processes can mitigate these issues. 

Despite OSes having mechanisms for mitigating these problems of access control and resource consumption, they are difficult to scale in complex systems. That is where virtualization comes in. A hypervisor is a translation layer from the hardware to the virtual machine, and also acts as a reference monitor. It mediates access to the hardware between process, which in the case of the hypervisor are virtual machines. It provides a limited namespace so that there is no leakage between VMs. It also provides programming abstraction to perform the programming duties. A VM also provides isolation at different levels, it can have different operating systems, different virtual disks, different ip addresses, and MAC address. When one VM crashes it does not affect other VMs. There are three types of virtualization, type 1a, type 1b, and type 2.

Type 1a has a hypervisor that runs on top of the hardware layer and on top of the that are the unique operating systems, with the hypervisor acting as a totally separate amount of hardware. It's easy to reason about perforance in this technique. But in every virtual OS you have a totally separate kernel and all other intensive resources. Type 1b requires that each OS be the same type like Linux. This means that every process in addition to having userids has a virtual machine id to know which version of the VM it's running in. The kernel is basically shared. There's much lower overhead in this case. Type 2 runs in its own process or application like VMware. You have your operating system that then installs the application that runs the virtual machine inside it. It has high overhead because your creating a new OS in each virtual machine. Since the interface between the low level OS and the application, and the high level OS and the application is complicated then security becomes an issue. Containers like Docker, have every program you're going to run in separate containers. These run on top of the docker engine that runs on top of the OS. 

VM's can be resource intensive especially if you consider type 1a. If you run a bunch of OS versions, you can have the same file take up more than one version amount of space on the hardware because each OS is separate. The resource use is not great, plus booting up each OS takes time. Containerization tries to address this issue with resource use by running on top of one OS and each container using the same resources across the system. In a container system, instead of the hypervisor you have a docker daemon (in the case of Docker) that manages the running of new containers. On top of the deamon sit the containers that have all the code necessary for running the program. The docker daemon isolates each application and allows for performance gains. Though if the OS that sits underneath everything is compromised then the container system is compromised as well. 

Virtual machines can also be used for the purposes of programming, to have cross platform compatibility, and to check code for safety at compile and run time. Python code is not compiled for the system it is run on. It is compiled into byte code and then on the system it is going to be run on is a virtual machine. The VM converts the bytecode and translates it to machine code for the architecture of that system. This type of language is called an interpreted language. This creates issues if there are any bugs in the VM, as it could compromise the whole system. They have complete trust in running arbitrary code and issues with code could lead to unwanted outcomes. The standard libraries for these types of languages tend to be very large because it represents a trusted code base, and rewriting these would take a lot of effort. Inside these trusted code bases are found many bugs that make security an issue. The standard libraries can be written by many different parties and not necessarily checked for all the bugs possible. 

Software fault isolation takes processes that live in the same hardware address space, and isolates them in their own logical fault domains. It checks for unwanted jumps in memory. An inline reference monitor checks for more than just memory safety. NACL is an example of a software fault isolation. It runs close to native speeds.

